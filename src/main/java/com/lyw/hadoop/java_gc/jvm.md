# java 虚拟机

- Java虚拟机内存划分
    - 线程共享：
        - 堆内存：存放各种实例对象数据
        - 方法区：类内存（存放类信息）
                数据内存：运行时数据常量池
                ![class文件](java内存.png)
             classLoader类加载：
            1. class二进制文件读入内存，将其放在运行时数据区的方法区内 (
                <font color=#0009ff>字面量、符号引用会放入常量池中，其他的信息放在metaspace元空间</font>)          
            2. 然后堆中创建一个java.lang.Class对象，用来封装类在方法区内的内数据结构
                            类加载的最终产品是堆区中的Class对象。                 
                           
    - 线程私有：
        - 程序计数器：记录线程执行字节码指令的行数
        - java虚拟栈：Java一个方法对应着一个栈帧（栈帧是虚拟机用来实现函数调用的数据结构），一个方法的调用对应着
            栈帧的入栈、出栈。栈帧保存的信息：方法的局部变量表、方法返回地址、动态链接、操作数栈。因此在编译期就可以
            知道需要多大的局部变量空间，和多深的操作数栈。所以栈帧需要的内存空间是确定的。
            1. 局部变量不会默认初始化值。
            2. 动态链接：class文件中常量池中有很多的变量符号引用。因为在编译的时并不知道所引用对象真实的内存地址，
            就用符号引用代替。等到类加载时或者运行时，将符号引用解析为直接引用，或者对象句柄。这样当它以后再次遇到相同的引用时，
            它就可以立即使用这个直接引用，而不必花时间再次解析这个符号引用了。
            3. 操作数栈：可以实现参数值，和参数列表的传递。iconst_5;istore_1;将常量5入栈，然后将数字5从栈pop,store到索引为1的变量槽（slot)
            eg:数字相加也是在操作数栈里面完成。将栈顶的2个数字取出相加，然后将和入栈。
            4. 局部变量表：如果是非static方法，索引为0的slot是实例化对象引用this。其他的存入的是方法参数和局部变量。局部变量表
            空间slot是可以复用的。
            ```java 
            public class SlotTest{
            
                pubulic void method1(){
                     {byte[] b = new byte[1024*1024];}
                     int a =0;
                     System.gc();
                } 
                
                /**
                *1。如果没有int a= 0；gc的时候因为局部变量表中slot里面的数值没有被重写，还存byte[]的引用，所以不会回收
                *2、a=0;因为b已经超出作用域了，变量槽复用原则，a会重写b的变量槽slot,byte[]的引用没有了，所以会gc回收
                *
                */
               
            }     
            ```
            5. 方法返回地址：当前栈帧出栈时恢复到上个栈帧调用的位置。
        - native方法栈：与Java虚拟栈基本相同，只不过执行的是native方法。
        
        
- java类实例化 
    - 当执行new实例化对象<font color=red>每个实例对象都有该类Class对象的引用</font>
       1. 去constant pool检查是否有该对象的符号引用。如果没有找到先执行类的加载过程生成class对象
       2. 根据符号引用获取对象类型，父类，接口、方法等信息。然后在堆内存中分配内存，更新符号引用为直接引用
       